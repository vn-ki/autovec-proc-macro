use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn autovec(_: TokenStream, input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as ItemFn);

    let preamble = get_preamble(ast.sig.clone());
    let ident = ast.sig.ident;
    let new_ident = syn::Ident::new(&format!("_{}_autogenerated_autovec", ident), ident.span());
    let fn_generics = ast.sig.generics.clone();

    let inputs = ast.sig.inputs.iter().map(|f| match f {
        syn::FnArg::Typed(p) => p,
        _ => panic!("self not allowed"),
    });

    // edge case santitzation
    // no input args
    if inputs.len() == 0 {
        panic!("expected at least one argument")
    }
    // variadic input
    if ast.sig.variadic.is_some() {
        panic!("variadic input isnt supported");
    }

    let orig_return_type = ast.sig.output.clone();
    let return_type = match ast.sig.output {
        syn::ReturnType::Type(_r, t) => quote! { Vec<#t> },
        _ => panic!("Function need to return a type"),
    };

    let no_args = inputs.len();
    let mut orig_func_input_names: Vec<proc_macro2::TokenStream> = Vec::with_capacity(no_args);
    let mut func_input_names: Vec<proc_macro2::TokenStream> = Vec::with_capacity(no_args);
    let mut func_input_types: Vec<proc_macro2::TokenStream> = Vec::with_capacity(no_args);
    let mut func_input_ref_types: Vec<proc_macro2::TokenStream> = Vec::with_capacity(no_args);
    for arg in inputs.clone() {
        match *arg.pat {
            syn::Pat::Ident(ref i) => {
                let t = i.ident.clone();
                orig_func_input_names.push(quote! { #t });
                let argname = syn::Ident::new(&format!("{}_vec", t), t.span());
                func_input_names.push(quote! { #argname });
            },
            syn::Pat::Tuple(ref t) => {
                orig_func_input_names.push(quote! { #t });
                func_input_names.push(quote! { arg1 })
            },
            syn::Pat::Struct(ref t) => {
                orig_func_input_names.push(quote! { #t });
                func_input_names.push(quote! { arg1 })
            },
            _ => unimplemented!(),
        }
        let ty = arg.ty.clone();
        func_input_ref_types.push(quote! { &#ty });
        func_input_types.push(quote! { Vec<#ty> });
    }

    let first_arg_name = &func_input_names[0];

    let block = ast.block;

    TokenStream::from(quote! {
        #preamble fn #new_ident#fn_generics (#(#orig_func_input_names : #func_input_ref_types, )*) #orig_return_type #block

        #preamble fn #ident#fn_generics(#(#func_input_names : #func_input_types, )*) -> #return_type {
            let n = #first_arg_name.len();
            #(
                if n != #func_input_names.len() {
                    panic!(concat!(stringify!(#func_input_names), " len does not match with other vectors"));
                }
            )*
            let mut ret: #return_type = Vec::with_capacity(n);

            for i in 0..n {
                ret.push(#new_ident( #(&#func_input_names[i],)* ));
            }
            return ret;
        }
    })
}

fn get_preamble(sig: syn::Signature) -> proc_macro2::TokenStream {
    let constness = sig.constness;
    let asyncness = sig.asyncness;
    quote! {
        #constness#asyncness
    }
}
